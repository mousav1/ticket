// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tickets.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPenalty = `-- name: CreatePenalty :one
INSERT INTO penalties (bus_id, actual_hours_before, hours_before, percent, custom_text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, bus_id, actual_hours_before, hours_before, percent, custom_text
`

type CreatePenaltyParams struct {
	BusID             pgtype.Int4
	ActualHoursBefore pgtype.Float8
	HoursBefore       pgtype.Float8
	Percent           int32
	CustomText        pgtype.Text
}

func (q *Queries) CreatePenalty(ctx context.Context, arg CreatePenaltyParams) (Penalty, error) {
	row := q.db.QueryRow(ctx, createPenalty,
		arg.BusID,
		arg.ActualHoursBefore,
		arg.HoursBefore,
		arg.Percent,
		arg.CustomText,
	)
	var i Penalty
	err := row.Scan(
		&i.ID,
		&i.BusID,
		&i.ActualHoursBefore,
		&i.HoursBefore,
		&i.Percent,
		&i.CustomText,
	)
	return i, err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM tickets
WHERE id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTicket, id)
	return err
}

const getBusPenalties = `-- name: GetBusPenalties :many
SELECT id, bus_id, actual_hours_before, hours_before, percent, custom_text
FROM penalties
WHERE bus_id = $1
`

func (q *Queries) GetBusPenalties(ctx context.Context, busID pgtype.Int4) ([]Penalty, error) {
	rows, err := q.db.Query(ctx, getBusPenalties, busID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Penalty
	for rows.Next() {
		var i Penalty
		if err := rows.Scan(
			&i.ID,
			&i.BusID,
			&i.ActualHoursBefore,
			&i.HoursBefore,
			&i.Percent,
			&i.CustomText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservedTicketsCount = `-- name: GetReservedTicketsCount :one
SELECT COUNT(*)
FROM tickets
WHERE bus_id = $1
`

func (q *Queries) GetReservedTicketsCount(ctx context.Context, busID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, getReservedTicketsCount, busID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT id, user_id, bus_id, reserved_at
FROM tickets
WHERE id = $1
`

type GetTicketByIDRow struct {
	ID         int32
	UserID     pgtype.Int4
	BusID      pgtype.Int4
	ReservedAt pgtype.Timestamptz
}

func (q *Queries) GetTicketByID(ctx context.Context, id int32) (GetTicketByIDRow, error) {
	row := q.db.QueryRow(ctx, getTicketByID, id)
	var i GetTicketByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusID,
		&i.ReservedAt,
	)
	return i, err
}

const getUserTickets = `-- name: GetUserTickets :many
SELECT t.id, b.route_id, b.departure_time, b.arrival_time, b.capacity, b.price, b.bus_type, b.corporation, b.super_corporation, b.service_number, b.is_vip
FROM tickets t
JOIN buses b ON t.bus_id = b.id
WHERE t.user_id = $1
`

type GetUserTicketsRow struct {
	ID               int32
	RouteID          pgtype.Int4
	DepartureTime    pgtype.Timestamptz
	ArrivalTime      pgtype.Timestamptz
	Capacity         int32
	Price            int32
	BusType          string
	Corporation      pgtype.Text
	SuperCorporation pgtype.Text
	ServiceNumber    pgtype.Text
	IsVip            pgtype.Bool
}

func (q *Queries) GetUserTickets(ctx context.Context, userID pgtype.Int4) ([]GetUserTicketsRow, error) {
	rows, err := q.db.Query(ctx, getUserTickets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTicketsRow
	for rows.Next() {
		var i GetUserTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.Capacity,
			&i.Price,
			&i.BusType,
			&i.Corporation,
			&i.SuperCorporation,
			&i.ServiceNumber,
			&i.IsVip,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reserveTicket = `-- name: ReserveTicket :exec
INSERT INTO tickets (user_id, bus_id, seat_id)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, bus_id, seat_id) DO NOTHING
`

type ReserveTicketParams struct {
	UserID pgtype.Int4
	BusID  pgtype.Int4
	SeatID pgtype.Int4
}

func (q *Queries) ReserveTicket(ctx context.Context, arg ReserveTicketParams) error {
	_, err := q.db.Exec(ctx, reserveTicket, arg.UserID, arg.BusID, arg.SeatID)
	return err
}
